<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cottontail - Innovation Numérique</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Spline+Sans:wght@300;400;500;600;700&family=Noto+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet" />
    
    <!-- External CSS - Utilisation de ./ pour forcer le chemin relatif -->
    <link rel="stylesheet" href="./styles.css">
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <header id="header">
        <div class="container header-inner">
            <div class="logo">
                <img src="./logo/dessin.svg" alt="Cottontail" class="logo-image logo-mobile" />
                <img src="./images/logo_complet.png" alt="Cottontail" class="logo-image logo-desktop" />
            </div>
            <nav class="main-nav">
                <a href="#hero" class="nav-link active" data-color="blue">Innovation</a>
                <a href="#expertise" class="nav-link" data-color="orange">Expertise</a>
                <a href="#perspective" class="nav-link" data-color="yellow">Perspective</a>
                <a href="#realisations" class="nav-link" data-color="navy">Réalisations</a>
            </nav>

            <!-- Navigation Cube -->
            <div class="mobile-nav-cube" id="mobileNavCube">
                <div class="cube-container">
                    <div class="cube" id="navCube">
                        <div class="cube-face cube-face-front" data-section="hero" data-color="blue">Innovation</div>
                        <div class="cube-face cube-face-right" data-section="expertise" data-color="orange">Expertise</div>
                        <div class="cube-face cube-face-back" data-section="perspective" data-color="yellow">Perspective</div>
                        <div class="cube-face cube-face-left" data-section="realisations" data-color="navy">Réalisations</div>
                        <div class="cube-face cube-face-top" data-section="contact" data-color="blue">Contact</div>
                    </div>
                </div>
            </div>
            <a href="#contact" class="btn-contact">Contact</a>
        </div>
    </header>

    <main>
        <section class="hero" id="hero">
            <div class="container">
                <h1 class="hero-title">L'Innovation numérique,<br><span class="blue hero-word-animate">maîtrisée.</span></h1>

                <div class="carousel-wrapper">
                    <div class="carousel-container" id="carousel">
                        <!-- Spacer invisible pour centrer la première carte -->
                        <div class="carousel-spacer"></div>

                        <!-- Slide 1 - Expertise IA -->
                        <div class="project-card slide-card" data-slide="0">
                            <div class="card-bg slide-bg-dark"></div>
                            <div class="slide-content-centered">
                                <div class="slide-text-container">
                                    <div class="slide-main-text apple-text-reveal">
                                        <span class="text-line" data-delay="0">Sécurisé.</span>
                                        <span class="text-line" data-delay="1">Maîtrisé.</span>
                                        <span class="text-line" data-delay="2">Utile.</span>
                                    </div>
                                    <p class="slide-subtext apple-fade-in">IA déployée sur vos infrastructures, selon vos contraintes.</p>
                                </div>
                                <a href="#contact" class="slide-cta-btn">Discuter de votre projet</a>
                            </div>
                        </div>

                        <!-- Slide 2 - Perspective -->
                        <div class="project-card slide-card" data-slide="1">
                            <div class="card-bg slide-bg-dark"></div>
                            <div class="slide-content-centered">
                                <div class="slide-text-container">
                                    <div class="slide-main-text apple-text-reveal">
                                        <span class="text-line" data-delay="0">Penser plus loin</span>
                                        <span class="text-line" data-delay="1">que la première version.</span>
                                    </div>
                                    <p class="slide-subtext apple-fade-in">Évolutivité, rentabilité, vision globale.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Slide 3 - Réalisation -->
                        <div class="project-card slide-card" data-slide="2">
                            <div class="card-bg slide-bg-dark"></div>
                            <div class="slide-content-centered">
                                <div class="slide-text-container">
                                    <div class="slide-main-text apple-text-reveal">
                                        <span class="text-line" data-delay="0">Quand le numérique</span>
                                        <span class="text-line" data-delay="1">s'intègre au réel.</span>
                                    </div>
                                    <p class="slide-subtext apple-fade-in">Processus métier, données, décisions humaines.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Spacer invisible pour centrer la dernière carte -->
                        <div class="carousel-spacer"></div>
                    </div>

                </div>
            </div>
        </section>

        <section class="expertise" id="expertise">
            <!-- Animation Expertise - 3 phases avec scroll hijacking -->
            <div class="expertise-animation" id="expertiseAnimation" data-current-phase="1">

                <!-- Téléphone unique qui se déplace entre les phases -->
                <div class="unified-phone" id="unifiedPhone">
                    <img src="./images/expertise/blank-phone.png" alt="Phone" class="phone-image">

                    <!-- Contenu Phase 1: Animation flux de données -->
                    <div class="phone-content content-phase-1">
                        <div class="data-flow-animation">
                            <!-- Noeuds du schéma -->
                            <div class="flow-node node-user">
                                <span class="material-symbols-outlined">person</span>
                            </div>
                            <!-- <div class="flow-node node-db">
                                <span class="material-symbols-outlined">database</span>
                            </div>
                            <div class="flow-node node-api">
                                <span class="material-symbols-outlined">api</span>
                            </div> -->
                            <!-- <div class="flow-node node-llm">
                                <span class="material-symbols-outlined">psychology</span>
                            </div> -->

                            <!-- Lignes de connexion avec particules -->
                            <svg class="flow-lines" viewBox="0 0 120 200" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
                                <defs>
                                    <!-- Trajectoires principales -->
                                    <path id="flow-left-to-user" d="M18 178 C30 150 44 105 60 58" />
                                    <path id="flow-right-to-user" d="M102 178 C90 150 76 105 60 58" />
                                    <path id="flow-left-to-right" d="M18 178 Q60 198 102 178" />
                                    <path id="flow-right-to-left" d="M102 178 Q60 198 18 178" />
                                </defs>

                                <g class="flow-guides">
                                    <use href="#flow-left-to-user" class="flow-path" />
                                    <use href="#flow-right-to-user" class="flow-path" />
                                    <use href="#flow-left-to-right" class="flow-path" />
                                    <use href="#flow-right-to-left" class="flow-path" />
                                </g>

                                <g class="flow-origins">
                                    <circle class="flow-origin" cx="18" cy="178" r="2" />
                                    <circle class="flow-origin" cx="102" cy="178" r="2" />
                                </g>

                                <g class="flow-particles">
                                    <!-- Particules qui remontent vers l'utilisateur -->
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.8s" repeatCount="indefinite" keyTimes="0;0.75;1" keyPoints="0;1;1" calcMode="linear">
                                            <mpath href="#flow-left-to-user" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="3.2s" begin="-1.4s" repeatCount="indefinite" keyTimes="0;0.7;1" keyPoints="0;1;1" calcMode="linear">
                                            <mpath href="#flow-right-to-user" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.6s" begin="-0.8s" repeatCount="indefinite" keyTimes="0;0.8;1" keyPoints="0;1;1" calcMode="linear">
                                            <mpath href="#flow-left-to-user" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="3s" begin="-0.5s" repeatCount="indefinite" keyTimes="0;0.78;1" keyPoints="0;1;1" calcMode="linear">
                                            <mpath href="#flow-right-to-user" />
                                        </animateMotion>
                                    </circle>

                                    <!-- Particules qui traversent A ↔ B -->
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.4s" repeatCount="indefinite" keyTimes="0;0.5;1" keyPoints="0;1;0" calcMode="linear">
                                            <mpath href="#flow-left-to-right" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.7s" begin="-1.1s" repeatCount="indefinite" keyTimes="0;0.5;1" keyPoints="0;1;0" calcMode="linear">
                                            <mpath href="#flow-right-to-left" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.9s" begin="-0.6s" repeatCount="indefinite" keyTimes="0;0.5;1" keyPoints="0;1;0" calcMode="linear">
                                            <mpath href="#flow-left-to-right" />
                                        </animateMotion>
                                    </circle>
                                    <circle class="flow-particle" r="1.6">
                                        <animateMotion dur="2.5s" begin="-0.3s" repeatCount="indefinite" keyTimes="0;0.5;1" keyPoints="0;1;0" calcMode="linear">
                                            <mpath href="#flow-right-to-left" />
                                        </animateMotion>
                                    </circle>
                                </g>
                            </svg>
                        </div>
                    </div>

                    <!-- Contenu Phase 2: Logo Lupin + Loader pourcentage -->
                    <div class="phone-content content-phase-2">
                        <div class="phase2-loader-container">
                            <img src="./images/expertise/logo_lupin.png" alt="Lupin" class="loader-logo">
                            <span class="loader-percentage" id="loaderPercentage">0%</span>
                            <span class="loader-text">Votre assistant IA se charge</span>
                        </div>
                    </div>

                    <!-- Flèche sous le téléphone (Phase 2) -->
                    <span class="scroll-arrow" id="scrollArrow">
                        <span class="material-symbols-outlined">keyboard_arrow_down</span>
                    </span>

                    <!-- Contenu Phase 3: Screenshot -->
                    <div class="phone-content content-phase-3">
                        <img src="./images/expertise/screenshot-phase3.jpg" alt="Application Lupin" class="phone-screenshot">
                    </div>
                </div>

                <!-- Phase 1: Diagramme complet -->
                <div class="expertise-phase phase-1 active" data-phase="1">
                    <div class="diagram-container">
                        <!-- Conteneur SVG Phase 1 -->
                        <div class="diagram-svg-wrapper">
                            <img src="./images/expertise/phase1.svg"
                                 alt="Architecture Phase 1"
                                 class="phase1-svg-diagram">
                        </div>
                    </div>
                </div>

                <!-- Phase 2: Loader + icônes animées depuis le téléphone -->
                <div class="expertise-phase phase-2" data-phase="2">
                    <!-- Icônes qui émergent du téléphone -->
                    <div class="phase2-icons-container">
                        <div class="phase2-icon icon-interface">
                            <span class="material-symbols-outlined">dashboard</span>
                            <span class="icon-label">Interface</span>
                        </div>
                        <div class="phase2-icon icon-connectivity">
                            <span class="material-symbols-outlined">hub</span>
                            <span class="icon-label">Connectivité</span>
                        </div>
                        <div class="phase2-icon icon-data">
                            <span class="material-symbols-outlined">shield_lock</span>
                            <span class="icon-label">Données sécurisées</span>
                        </div>
                    </div>
                </div>

                <!-- Phase 3: Texte elegant style -->
                <div class="expertise-phase phase-3" data-phase="3">
                    <div class="phase3-content">
                        <!-- Texte elegant style -->
                        <div class="elegant-text">
                            <p class="elegant-line line-1">Vous avez une idée.</p>
                            <p class="elegant-line line-2">On <span class="orange">s'occupe</span> du reste.</p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- Perspective -->
        <section class="perspective" id="perspective">
            <div class="container perspective-header">
                <h2 class="section-title">Une perspective <span class="yellow">durable.</span></h2>
                <p class="perspective-lead">Après le produit, le cap à tenir : valeur, évolutivité, partenariat.</p>
            </div>

            <div class="perspective-grid">
                <div class="perspective-card">
                    <h3>Une perspective rentable.</h3>
                    <p class="perspective-key">Chaque projet doit générer de la valeur.</p>
                    <ul class="perspective-points">
                        <li>Temps gagné, ressources optimisées, décisions éclairées.</li>
                        <li>La technologie n’est jamais une fin en soi.</li>
                    </ul>
                    <p class="perspective-body">Un logiciel n’est utile que s’il améliore réellement votre activité. Nous concevons chaque solution avec un objectif clair : un retour sur investissement mesurable.</p>
                </div>

                <div class="perspective-card">
                    <h3>Une perspective évolutive.</h3>
                    <p class="perspective-key">Les besoins changent. Le logiciel doit suivre sans tout refaire.</p>
                    <ul class="perspective-points">
                        <li>Architecture pensée pour durer.</li>
                        <li>Adaptable sans rupture ni dette inutile.</li>
                    </ul>
                    <p class="perspective-body">Vos outils doivent s’adapter à votre croissance, pas la freiner. Nos solutions sont conçues pour évoluer, sans rupture ni dette inutile.</p>
                </div>

                <div class="perspective-card">
                    <h3>Une perspective durable.</h3>
                    <p class="perspective-key">Une relation à long terme.</p>
                    <ul class="perspective-points">
                        <li>Accompagnement dans le temps, vision commune.</li>
                        <li>Présence technique et humaine continue.</li>
                    </ul>
                    <p class="perspective-body">Nous ne livrons pas un produit et disparaissons. Nous construisons un partenariat capable de traverser les évolutions de votre activité.</p>
                </div>
            </div>
        </section>

        <!-- Réalisations -->
        <section class="realisations" id="realisations">
            <div class="container realisations-header">
                <h2 class="section-title">Quand l’approche prend <span class="navy">forme.</span></h2>
            </div>

            <div class="realisations-grid">
                <div class="realisation-card">
                    <h3>Optimisation d’un outil métier</h3>
                    <ul>
                        <li><strong>Problème :</strong> saisies lentes, erreurs fréquentes.</li>
                        <li><strong>Solution :</strong> refonte des workflows et automatisation ciblée.</li>
                        <li><strong>Bénéfice :</strong> gain de temps, fiabilité accrue, adoption rapide.</li>
                    </ul>
                </div>
                <div class="realisation-card">
                    <h3>Plateforme évolutive B2B</h3>
                    <ul>
                        <li><strong>Problème :</strong> ajout de nouvelles offres bloqué par l’existant.</li>
                        <li><strong>Solution :</strong> architecture modulaire et API stabilisées.</li>
                        <li><strong>Bénéfice :</strong> nouveaux services déployés sans rupture.</li>
                    </ul>
                </div>
                <div class="realisation-card">
                    <h3>Casviande.fr</h3>
                    <ul>
                        <li><strong>Problème :</strong> besoin de moderniser un outil métier critique.</li>
                        <li><strong>Solution :</strong> interface repensée, process sécurisés.</li>
                        <li><strong>Bénéfice :</strong> productivité accrue et confiance des équipes.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="contact" id="contact">
            <div class="contact-header">
                <h2>Parlons de votre projet.</h2>
                <p>Une idée, un besoin ? Nous sommes là pour vous accompagner.</p>
            </div>

            <div class="bento-grid">
                <!-- Grande carte Map - occupe 2 colonnes -->
                <div class="bento-card bento-map">
                    <img src="./images/Icone.PNG" alt="Cottontail" class="bento-map-image">
                    <iframe
                        src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d166.30304912080229!2d6.451889037412049!3d48.17099556282759!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x4793a08efd32d2f5%3A0x6b697bf99e10bb8d!2s5%20Rue%20des%20Jardiniers%2C%2088000%20%C3%89pinal!5e0!3m2!1sfr!2sfr!4v1765880135382!5m2!1sfr!2sfr"
                        allowfullscreen=""
                        loading="lazy"
                        referrerpolicy="no-referrer-when-downgrade">
                    </iframe>
                </div>

                <!-- Carte Téléphone -->
                <a href="tel:+33685680467" class="bento-card bento-phone">
                    <div class="bento-icon">
                        <span class="material-symbols-outlined">phone</span>
                    </div>
                    <div class="bento-content">
                        <span class="bento-label">Téléphone</span>
                        <p class="bento-value">06 85 68 04 67</p>
                        <span class="bento-sub">Lun-Ven, 9h-18h</span>
                    </div>
                </a>

                <!-- Carte Email -->
                <a href="mailto:contact@cottontail-logiciels.fr" class="bento-card bento-email">
                    <div class="bento-icon">
                        <span class="material-symbols-outlined">mail</span>
                    </div>
                    <div class="bento-content">
                        <span class="bento-label">Email</span>
                        <p class="bento-value">contact@cottontail-logiciels.fr</p>
                        <span class="bento-sub">Réponse sous 24h</span>
                    </div>
                </a>

                <!-- Carte Adresse -->
                <a href="https://maps.google.com/?q=5+rue+des+jardiniers+88000+epinal" target="_blank" class="bento-card bento-address">
                    <div class="bento-icon">
                        <span class="material-symbols-outlined">location_on</span>
                    </div>
                    <div class="bento-content">
                        <span class="bento-label">Adresse</span>
                        <p class="bento-value">5 rue des Jardiniers</p>
                        <span class="bento-sub">88000 Épinal, France</span>
                    </div>
                </a>

                <!-- Carte CTA -->
                <div class="bento-card bento-cta">
                    <h3>Prêt à démarrer ?</h3>
                    <p>Discutons de votre projet ensemble</p>
                    <div class="bento-cta-buttons">
                        <a href="tel:+33685680467" class="bento-btn-secondary">
                            <span class="material-symbols-outlined">call</span>
                            Appeler
                        </a>
                        <a href="mailto:contact@cottontail-logiciels.fr" class="bento-btn-secondary">
                            <span class="material-symbols-outlined">mail</span>
                            Email
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            © 2023 Cottontail. Tous droits réservés.
        </div>
    </footer>

    <script>
        // Header scroll effect and navigation tracking
        const header = document.getElementById('header');
        const navLinks = document.querySelectorAll('.nav-link');
        const sections = document.querySelectorAll('section[id]');

        // Scroll effect for header
        let lastScroll = 0;
        window.addEventListener('scroll', () => {
            const currentScroll = window.pageYOffset;

            // Add scrolled class for styling
            if (currentScroll > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }

            lastScroll = currentScroll;
        });

        // Active navigation based on scroll position
        function updateActiveNav() {
            const scrollPos = window.pageYOffset + 100; // Offset for header height

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.offsetHeight;
                const sectionId = section.getAttribute('id');

                if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
                    // Update header border color based on section
                    header.setAttribute('data-section', sectionId);

                    navLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${sectionId}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }

        window.addEventListener('scroll', updateActiveNav);

        // Set initial active section
        updateActiveNav();

        // Force le scroll initial sur l'ancre #expertise (avec offset header)
        (function() {
            const expertiseAnchor = document.getElementById('expertise');
            if (!expertiseAnchor) return;
            const headerHeight = header?.offsetHeight || 0;
            requestAnimationFrame(() => {
                window.scrollTo({
                    top: expertiseAnchor.offsetTop - headerHeight,
                    behavior: 'auto'
                });
            });
        })();

        // Mobile Navigation Cube
        const navCube = document.getElementById('navCube');
        const cubeFaces = document.querySelectorAll('.cube-face');
        const sectionOrder = ['hero', 'expertise', 'perspective', 'realisations', 'contact'];
        let currentCubePosition = 0;

        function updateCubePosition(sectionId) {
            const newPosition = sectionOrder.indexOf(sectionId);
            if (newPosition !== -1 && newPosition !== currentCubePosition) {
                currentCubePosition = newPosition;
                // Rotation séquentielle suivant l'ordre souhaité
                const rotationMap = [
                    'rotateY(0deg)',      // hero
                    'rotateY(-90deg)',    // expertise (droite)
                    'rotateY(-180deg)',   // perspective (arrière)
                    'rotateY(90deg)',     // réalisations (gauche)
                    'rotateX(90deg)'      // contact (haut)
                ];
                navCube.style.transform = rotationMap[newPosition] || 'rotateY(0deg)';
            }
        }

        // Update cube when scrolling
        function updateMobileCube() {
            const scrollPos = window.pageYOffset + 100;

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.offsetHeight;
                const sectionId = section.getAttribute('id');

                if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
                    if (sectionOrder.includes(sectionId)) {
                        updateCubePosition(sectionId);
                    }
                }
            });
        }

        window.addEventListener('scroll', updateMobileCube);

        // Click on cube face to navigate
        cubeFaces.forEach(face => {
            face.addEventListener('click', () => {
                const targetSection = face.getAttribute('data-section');
                const targetElement = document.getElementById(targetSection);

                if (targetElement) {
                    const headerHeight = header.offsetHeight;
                    const targetPosition = targetElement.offsetTop - headerHeight;

                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Initialize cube position
        updateMobileCube();

        // Smooth scroll for navigation links
        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);

                if (targetSection) {
                    const headerHeight = header.offsetHeight;
                    const targetPosition = targetSection.offsetTop - headerHeight;

                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Smooth scroll for contact button
        const btnContact = document.querySelector('.btn-contact');
        if (btnContact) {
            btnContact.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = btnContact.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);

                if (targetSection) {
                    const headerHeight = header.offsetHeight;
                    const targetPosition = targetSection.offsetTop - headerHeight;
                    const startPosition = window.pageYOffset;
                    const distance = targetPosition - startPosition;
                    const duration = 1200; // Durée plus longue pour un scroll plus doux
                    let startTime = null;

                    function easeInOutCubic(t) {
                        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                    }

                    function animation(currentTime) {
                        if (startTime === null) startTime = currentTime;
                        const timeElapsed = currentTime - startTime;
                        const progress = Math.min(timeElapsed / duration, 1);
                        const ease = easeInOutCubic(progress);

                        window.scrollTo(0, startPosition + distance * ease);

                        if (timeElapsed < duration) {
                            requestAnimationFrame(animation);
                        }
                    }

                    requestAnimationFrame(animation);
                }
            });
        }

        // Carousel functionality
        const carousel = document.getElementById('carousel');
        const dots = document.querySelectorAll('.dot');
        const projectCards = document.querySelectorAll('.project-card');
        const carouselSpacer = document.querySelector('.carousel-spacer');

        function updateDots() {
            if (!carousel) return;
            const containerCenter = carousel.getBoundingClientRect().left + carousel.offsetWidth / 2;
            
            let closestIndex = 0;
            let minDistance = Infinity;

            projectCards.forEach((card, index) => {
                const cardRect = card.getBoundingClientRect();
                const cardCenter = cardRect.left + cardRect.width / 2;
                const distance = Math.abs(containerCenter - cardCenter);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });

            dots.forEach((dot, index) => {
                if (index === closestIndex) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        carousel.addEventListener('scroll', updateDots);
        // Initial check
        updateDots();

        function scrollCarousel(direction) {
            const cardWidth = projectCards[0].offsetWidth;
            const gap = 32; // 2rem
            const scrollAmount = cardWidth + gap;
            
            carousel.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
        }

        function scrollToIndex(index) {
            const targetCard = projectCards[index];
            const targetLeft = targetCard.offsetLeft;
            const containerWidth = carousel.offsetWidth;
            // -16 accounts for padding/margins roughly to center visually in the padded container
            const scrollPos = targetLeft - (containerWidth / 2) + (targetCard.offsetWidth / 2) - 16;

            carousel.scrollTo({
                left: scrollPos,
                behavior: 'smooth'
            });
        }

        // ==========================================
        // Scroll vertical → Navigation des slides
        // Desktop uniquement
        // ==========================================
        (function() {
            if (window.innerWidth < 768) return; // Désactivé sur mobile

            const heroSection = document.getElementById('hero');
            const heroTitle = heroSection.querySelector('h1');
            const carouselWrapper = document.querySelector('.carousel-wrapper');
            const expertiseSection = document.getElementById('expertise');
            let isAnimating = false;
            let lastWheelTime = 0;
            const totalSlides = projectCards.length;
            const heroScrollOffset = 16;
            const ANIMATION_DURATION = 300; // Durée réduite pour navigation rapide
            const THROTTLE_DELAY = 250; // Délai réduit entre scrolls
            let heroScrollLockY = null; // verrou de position pour éviter le scroll de page tant que slide > 0
            let heroLockActive = false; // verrou global pour la section hero
            let heroCooldownUntil = 0; // délai après sortie vers expertise

            // Système d'activation du scroll hijacking plus robuste
            let scrollHijackEnabled = false;
            let isCarouselHovering = false;
            let rapidScrollCount = 0;
            let lastRapidScrollTime = 0;
            let hijackReenableTimer = null;

            // Activer le hijacking uniquement au survol du carousel
            if (carousel) {
                carousel.addEventListener('mouseenter', () => {
                    isCarouselHovering = true;
                    scrollHijackEnabled = true;
                });

                carousel.addEventListener('mouseleave', () => {
                    isCarouselHovering = false;
                    scrollHijackEnabled = false;
                    if (hijackReenableTimer) {
                        clearTimeout(hijackReenableTimer);
                        hijackReenableTimer = null;
                    }
                });
            }

            // Récupère l'index de la slide actuellement visible
            function getCurrentSlideIndex() {
                const containerCenter = carousel.getBoundingClientRect().left + carousel.offsetWidth / 2;
                let closestIndex = 0;
                let minDistance = Infinity;

                projectCards.forEach((card, index) => {
                    const cardRect = card.getBoundingClientRect();
                    const cardCenter = cardRect.left + cardRect.width / 2;
                    const distance = Math.abs(containerCenter - cardCenter);

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = index;
                    }
                });

                return closestIndex;
            }

            // Scroll vers le titre h1 du hero
            function scrollToHeroTitle() {
                isAnimating = true;
                const headerHeight = header.offsetHeight;
                const targetPosition = Math.max(
                    heroTitle.offsetTop - headerHeight - heroScrollOffset,
                    0
                );
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
                setTimeout(() => { isAnimating = false; }, ANIMATION_DURATION);
            }

            // Scroll vers une slide spécifique (avec marquage animation)
            function scrollToSlide(index) {
                isAnimating = true;
                scrollToIndex(index);
                setTimeout(() => { isAnimating = false; }, ANIMATION_DURATION);
            }

            // Scroll direct vers la section expertise (avec offset header)
            function scrollToExpertiseSection() {
                if (!expertiseSection) return;
                isAnimating = true;
                const headerHeight = header?.offsetHeight || 0;
                const targetPosition = expertiseSection.offsetTop - headerHeight;
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
                setTimeout(() => { isAnimating = false; }, ANIMATION_DURATION + 100);
            }

            // Vérifie si on est au-dessus du hero (tout en haut de la page)
            function isAboveHero() {
                const headerHeight = header.offsetHeight;
                const triggerPoint = Math.max(
                    heroTitle.offsetTop - headerHeight - heroScrollOffset,
                    0
                );
                return window.scrollY < triggerPoint;
            }

            // Vérifie si on arrive depuis la section expertise (en remontant)
            function isAtExpertiseTop() {
                const rect = expertiseSection.getBoundingClientRect();
                return rect.top >= 0 && rect.top <= window.innerHeight;
            }

            // Vérifie si le carousel est bien visible à l'écran
            function isCarouselInView() {
                const rect = carouselWrapper.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const visibleTop = Math.max(0, rect.top);
                const visibleBottom = Math.min(viewportHeight, rect.bottom);
                const visibleHeight = visibleBottom - visibleTop;
                return visibleHeight > rect.height * 0.4;
            }

            // Vérifie si le titre hero est visible
            function isHeroTitleInView() {
                const rect = heroTitle.getBoundingClientRect();
                return rect.top >= -50 && rect.bottom <= window.innerHeight + 50;
            }

            // Gestionnaire du scroll vertical
            function handleWheelScroll(e) {
                if (window.innerWidth < 768) return;
                const activeSection = header?.getAttribute('data-section');
                if (activeSection && activeSection !== 'hero') return; // ne verrouille que dans Innovation
                if (Date.now() < heroCooldownUntil) {
                    e.preventDefault();
                    return;
                }

                const now = Date.now();
                const deltaY = e.deltaY;
                const currentSlide = getCurrentSlideIndex();
                const heroRect = heroSection.getBoundingClientRect();
                const heroInView = heroRect.top < window.innerHeight && heroRect.bottom > 0;
                const lockUp = heroInView && currentSlide > 0 && deltaY < 0;
                const lockDown = heroInView && currentSlide < totalSlides - 1 && deltaY > 0;

                heroLockActive = lockUp || lockDown;
                if (!heroLockActive) {
                    heroScrollLockY = null;
                }

                if (Math.abs(deltaY) < 30 && !heroLockActive) return;

                if (!isCarouselHovering && !heroLockActive) return;
                if (!scrollHijackEnabled && !heroLockActive) return;

                // Détection de scroll rapide répété (échappatoire utilisateur)
                if (now - lastRapidScrollTime < 150) {
                    rapidScrollCount++;
                    if (rapidScrollCount > 4) {
                        // L'utilisateur force le scroll, désactiver temporairement
                        scrollHijackEnabled = false;
                        if (hijackReenableTimer) {
                            clearTimeout(hijackReenableTimer);
                        }
                        hijackReenableTimer = setTimeout(() => {
                            if (isCarouselHovering) {
                                scrollHijackEnabled = true;
                            }
                            rapidScrollCount = 0;
                            hijackReenableTimer = null;
                        }, 1500);
                        return; // Laisser le scroll natif
                    }
                } else {
                    rapidScrollCount = 0;
                }
                lastRapidScrollTime = now;

                // Throttling: bloquer strictement pendant les animations
                if (isAnimating) {
                    e.preventDefault();
                    return;
                }
                if (now - lastWheelTime < THROTTLE_DELAY) {
                    if (heroLockActive) e.preventDefault();
                    return;
                }

                // CAS 1: On est tout en haut et on scroll vers le bas → aller au titre
                if (isAboveHero() && deltaY > 0) {
                    e.preventDefault();
                    lastWheelTime = now;
                    scrollToHeroTitle();
                    return;
                }

                // CAS 2: On est sur le titre et on scroll vers le bas → aller à la slide 0
                if (isHeroTitleInView() && !isCarouselInView() && deltaY > 0) {
                    e.preventDefault();
                    lastWheelTime = now;
                    scrollToSlide(0);
                    return;
                }

                // Verrouillage forcé (slide > 0) : remonter/avancer les slides avant tout scroll natif
                if (heroLockActive) {
                    e.preventDefault();
                    lastWheelTime = now;
                    if (heroScrollLockY === null) {
                        heroScrollLockY = window.scrollY;
                    }
                    // Empêcher le scroll de la page
                    window.scrollTo({ top: heroScrollLockY, behavior: 'auto' });
                    const targetIndex = lockUp ? currentSlide - 1 : currentSlide + 1;
                    const clampedIndex = Math.max(0, Math.min(totalSlides - 1, targetIndex));
                    if (clampedIndex !== currentSlide) {
                        scrollToSlide(clampedIndex);
                    } else if (!lockUp && currentSlide === totalSlides - 1) {
                        // Laisser filer vers le bas après la dernière slide
                        heroLockActive = false;
                        heroScrollLockY = null;
                    }
                    return;
                }

                // CAS 3: On est sur le carousel
                if (isCarouselInView()) {
                    if (deltaY > 0) {
                        // Scroll vers le bas
                        if (currentSlide < totalSlides - 1) {
                            e.preventDefault();
                            lastWheelTime = now;
                            scrollToSlide(currentSlide + 1);
                        } else {
                            // Dernière slide → bascule directement vers expertise
                            e.preventDefault();
                            lastWheelTime = now;
                            heroCooldownUntil = now + 1000; // délai d'une seconde avant de rescoller vers le bas
                            scrollToExpertiseSection();
                            return;
                        }
                    } else if (deltaY < 0) {
                        // Scroll vers le haut
                        if (isAtExpertiseTop()) {
                            e.preventDefault();
                            lastWheelTime = now;
                            scrollToHeroTitle();
                            return;
                        }
                        if (currentSlide > 0) {
                            e.preventDefault();
                            lastWheelTime = now;
                            scrollToSlide(currentSlide - 1);
                        } else {
                            e.preventDefault();
                            lastWheelTime = now;
                            scrollToHeroTitle();
                        }
                    }
                    return;
                }

                // CAS 4: On remonte depuis expertise → aller au titre
                if (isAtExpertiseTop() && e.deltaY < 0) {
                    e.preventDefault();
                    lastWheelTime = now;
                    scrollToHeroTitle();
                    // Remettre le carousel sur la dernière slide
                    setTimeout(() => {
                        scrollToSlide(totalSlides - 1);
                    }, 300);
                    return;
                }
            }

            window.addEventListener('wheel', handleWheelScroll, { passive: false });
        })();

        // ==========================================
        // Slide Card Active State & Animation
        // ==========================================
        (function() {
            const slideCards = document.querySelectorAll('.slide-card');
            let currentActiveSlide = -1;

            function updateActiveSlide() {
                if (!carousel) return;
                const containerCenter = carousel.getBoundingClientRect().left + carousel.offsetWidth / 2;

                let closestIndex = -1;
                let minDistance = Infinity;

                slideCards.forEach((card, index) => {
                    const cardRect = card.getBoundingClientRect();
                    const cardCenter = cardRect.left + cardRect.width / 2;
                    const distance = Math.abs(containerCenter - cardCenter);

                    if (distance < minDistance && distance < cardRect.width * 0.6) {
                        minDistance = distance;
                        closestIndex = index;
                    }
                });

                if (closestIndex !== currentActiveSlide) {
                    // Remove active from previous
                    slideCards.forEach((card, index) => {
                        if (index === currentActiveSlide && closestIndex !== -1) {
                            card.classList.add('slide-out-left');
                            card.classList.remove('active');
                            setTimeout(() => {
                                card.classList.remove('slide-out-left');
                            }, 400);
                        } else {
                            card.classList.remove('active');
                        }
                    });

                    // Add active to current
                    if (closestIndex !== -1) {
                        slideCards[closestIndex].classList.add('active');
                    }

                    currentActiveSlide = closestIndex;
                }
            }

            carousel.addEventListener('scroll', updateActiveSlide);
            // Initial check with delay to ensure proper positioning
            setTimeout(updateActiveSlide, 100);

            // Reset à la première slide quand on quitte le viewport du carousel
            let carouselWasInView = false;
            const carouselObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        carouselWasInView = true;
                    } else if (carouselWasInView) {
                        // On vient de sortir : revenir à la slide 0
                        scrollToIndex(0);
                        carouselWasInView = false;
                    }
                });
            }, { threshold: 0.2 });

            carouselObserver.observe(carousel);
        })();

        // ==========================================
        // Expertise Tiles - Apple-style Scroll Animation
        // ==========================================
        (function() {
            if (window.innerWidth < 768) return; // Disabled on mobile

            const expertiseSection = document.getElementById('expertise');
            const tilesContainer = document.getElementById('expertiseTiles');
            const tiles = tilesContainer?.querySelectorAll('.expertise-tile');
            const ctaButton = expertiseSection?.querySelector('.btn-cta');

            if (!expertiseSection || !tilesContainer || !tiles || !ctaButton) return;

            // Animation parameters
            const initialScale = 1.15;
            const finalScale = 1.0;
            const initialRotation = 15; // degrees for side tiles

            function updateTilesAnimation() {
                const sectionRect = expertiseSection.getBoundingClientRect();
                const tilesRect = tilesContainer.getBoundingClientRect();
                const ctaRect = ctaButton.getBoundingClientRect();
                const viewportHeight = window.innerHeight;

                // Calculate animation progress
                // Start when tiles enter viewport, end when CTA button reaches center
                const animationStart = viewportHeight; // tiles top enters viewport
                const animationEnd = viewportHeight * 0.4; // CTA near center

                // Current position of tiles top
                const currentPosition = tilesRect.top;

                // Calculate progress (0 = start, 1 = end)
                let progress = 0;
                if (currentPosition <= animationStart && currentPosition >= animationEnd) {
                    progress = (animationStart - currentPosition) / (animationStart - animationEnd);
                } else if (currentPosition < animationEnd) {
                    progress = 1;
                }

                // Clamp progress between 0 and 1
                progress = Math.max(0, Math.min(1, progress));

                // Apply easing (ease-out cubic)
                const easedProgress = 1 - Math.pow(1 - progress, 3);

                // Calculate current values
                const currentScale = initialScale - (initialScale - finalScale) * easedProgress;
                const currentRotation = initialRotation * (1 - easedProgress);

                // Apply to each tile
                tiles.forEach(tile => {
                    const tileIndex = parseInt(tile.dataset.tile);
                    let rotation = 0;

                    if (tileIndex === 0) {
                        rotation = -currentRotation; // Left tile rotates left
                    } else if (tileIndex === 2) {
                        rotation = currentRotation; // Right tile rotates right
                    }

                    tile.style.transform = `scale(${currentScale}) rotateY(${rotation}deg)`;
                });
            }

            // Use requestAnimationFrame for smooth animation
            let ticking = false;
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(() => {
                        updateTilesAnimation();
                        ticking = false;
                    });
                    ticking = true;
                }
            });

            // Initial call
            updateTilesAnimation();
        })();

        // ==========================================
        // Expertise Animation - Scroll Hijacking
        // ==========================================
        (function() {
            const expertiseSection = document.getElementById('expertise');
            const expertiseAnimation = document.getElementById('expertiseAnimation');
            const perspectiveSection = document.getElementById('perspective');
            const phases = document.querySelectorAll('.expertise-phase');
            const elegantText = document.querySelector('.elegant-text');

            if (!expertiseSection || !phases.length) return;

            // Le déclencheur principal est le conteneur d'animation
            const expertiseTrigger = expertiseAnimation || expertiseSection;

            let currentPhase = 0;
            let isAnimating = false;
            let isInExpertiseSection = false;
            let wasInExpertiseSection = false;
            let lastWheelTime = 0;
            const totalPhases = phases.length;
            const animationDuration = 400; // ms - Réduit pour navigation rapide
            const expertiseThrottleDelay = 350; // Délai entre scrolls (augmenté pour molette)

            // Protection contre le scroll rapide (molette)
            let rapidScrollCount = 0;
            let lastRapidScrollTime = 0;
            let scrollLocked = false;

            // Protection contre le spam scroll (changements de direction rapides)
            let lastScrollDirection = 0; // -1 = up, 1 = down, 0 = none
            let directionChangeCount = 0;
            let lastDirectionChangeTime = 0;
            const SPAM_DIRECTION_THRESHOLD = 3; // Nombre de changements de direction avant lock
            const SPAM_TIME_WINDOW = 800; // Fenêtre de temps pour détecter le spam (ms)
            const SPAM_LOCK_DURATION = 1000; // Durée du verrouillage après spam (ms)
            let spamLocked = false;
            let spamLockTimer = null;

            // Système d'accumulation pour différencier molette/trackpad
            let accumulatedDelta = 0;
            let lastDeltaTime = 0;
            const WHEEL_THRESHOLD = 80; // Seuil plus élevé pour la molette
            const TRACKPAD_THRESHOLD = 40; // Seuil pour trackpad
            const DELTA_RESET_TIME = 150; // Reset l'accumulation après ce délai

            // Variables pour le loader phase 2
            let loaderInterval = null;
            const loaderElement = document.getElementById('loaderPercentage');
            const scrollArrow = document.getElementById('scrollArrow');
            const loaderText = document.querySelector('.loader-text');
            const iconInterface = document.querySelector('.icon-interface');
            const iconConnectivity = document.querySelector('.icon-connectivity');
            const iconData = document.querySelector('.icon-data');

            // Initialiser la première phase comme active
            phases[0].classList.add('active');

            // Flag pour éviter les lancements multiples du loader
            let loaderRunning = false;
            let loaderProgress = 0;

            // Fonction pour animer le loader de 0% à 100%
            function animateLoader() {
                if (!loaderElement) return;

                // Éviter les lancements multiples
                if (loaderRunning) return;

                // Arrêter tout intervalle existant
                if (loaderInterval) {
                    clearInterval(loaderInterval);
                    loaderInterval = null;
                }

                loaderRunning = true;
                loaderProgress = 0;
                const duration = 2000; // 2 secondes
                const steps = 100;
                const stepDuration = duration / steps;

                loaderElement.textContent = '0%';

                loaderInterval = setInterval(() => {
                    // Protection: ne jamais dépasser 100
                    if (loaderProgress >= 100) {
                        clearInterval(loaderInterval);
                        loaderInterval = null;
                        loaderRunning = false;
                        return;
                    }

                    loaderProgress++;
                    // Double protection: forcer le max à 100
                    const displayProgress = Math.min(loaderProgress, 100);
                    loaderElement.textContent = displayProgress + '%';

                    // Apparition des icônes dans l'ordre (avant 100%)
                    if (displayProgress >= 25 && iconInterface) {
                        iconInterface.classList.add('visible');
                    }
                    if (displayProgress >= 50 && iconConnectivity) {
                        iconConnectivity.classList.add('visible');
                    }
                    if (displayProgress >= 75 && iconData) {
                        iconData.classList.add('visible');
                    }

                    if (displayProgress >= 100) {
                        clearInterval(loaderInterval);
                        loaderInterval = null;
                        loaderRunning = false;

                        // Changer le texte à 100%
                        if (loaderText) {
                            loaderText.textContent = 'IA chargée';
                            loaderText.classList.add('loaded');
                        }

                        // Afficher la flèche après 0.5s
                        setTimeout(() => {
                            if (scrollArrow) {
                                scrollArrow.classList.add('visible');
                            }
                        }, 500);
                    }
                }, stepDuration);
            }

            // Fonction pour arrêter le loader et cacher la flèche
            function stopLoader() {
                // Arrêter l'intervalle
                if (loaderInterval) {
                    clearInterval(loaderInterval);
                    loaderInterval = null;
                }
                // Réinitialiser les flags
                loaderRunning = false;
                loaderProgress = 0;
                // Réinitialiser l'affichage
                if (loaderElement) {
                    loaderElement.textContent = '0%';
                }
                if (loaderText) {
                    loaderText.textContent = 'Votre assistant IA se charge';
                    loaderText.classList.remove('loaded');
                }
                if (scrollArrow) {
                    scrollArrow.classList.remove('visible');
                }
                // Cacher les icônes
                if (iconInterface) iconInterface.classList.remove('visible');
                if (iconConnectivity) iconConnectivity.classList.remove('visible');
                if (iconData) iconData.classList.remove('visible');
            }

            // Variable pour le pinning
            let isPinned = false;
            let pinnedScrollPosition = 0;

            // Calculer la position idéale de pinning (section centrée/visible)
            function calculatePinPosition() {
                const headerHeight = header?.offsetHeight || 72;
                // Position où le haut de la section expertise est juste sous le header
                return expertiseSection.offsetTop - headerHeight;
            }

            // Fonction pour activer le pinning
            function enablePinning() {
                if (isPinned) return;
                isPinned = true;

                // Calculer la position idéale pour la section
                const idealPosition = calculatePinPosition();
                const currentScroll = window.scrollY;

                // Si on est trop loin de la position idéale, y aller
                if (Math.abs(currentScroll - idealPosition) > 100) {
                    window.scrollTo({
                        top: idealPosition,
                        behavior: 'instant'
                    });
                    pinnedScrollPosition = idealPosition;
                } else {
                    pinnedScrollPosition = currentScroll;
                }

                expertiseSection.classList.add('scroll-pinned');
            }

            // Fonction pour désactiver le pinning
            function disablePinning() {
                if (!isPinned) return;
                isPinned = false;
                expertiseSection.classList.remove('scroll-pinned');
            }

            // Forcer le scroll à rester en place quand piégé
            function enforcePin() {
                if (isPinned && Math.abs(window.scrollY - pinnedScrollPosition) > 5) {
                    window.scrollTo({
                        top: pinnedScrollPosition,
                        behavior: 'instant'
                    });
                }
            }

            // Fonction pour changer de phase
            function goToPhase(phaseIndex) {
                if (phaseIndex < 0 || phaseIndex >= totalPhases) return;
                if (phaseIndex === currentPhase) return;

                isAnimating = true;

                // Arrêter le loader si on quitte la phase 2
                if (currentPhase === 1) {
                    stopLoader();
                }

                // Activer le pinning si on est au milieu des phases
                if (phaseIndex > 0 && phaseIndex < totalPhases - 1) {
                    enablePinning();
                } else {
                    // Désactiver le pinning si on est à la première ou dernière phase
                    disablePinning();
                }

                // Retirer active de la phase actuelle
                phases[currentPhase].classList.remove('active');

                // Ajouter active à la nouvelle phase
                phases[phaseIndex].classList.add('active');

                // Mettre à jour l'attribut pour le téléphone unifié
                expertiseAnimation.setAttribute('data-current-phase', phaseIndex + 1);

                currentPhase = phaseIndex;

                // Phase 2: Lancer le loader
                if (currentPhase === 1) {
                    setTimeout(() => {
                        animateLoader();
                    }, 600); // Attendre que l'animation du téléphone soit terminée
                }

                // Activer l'animation du texte elegant sur la phase 3
                if (currentPhase === 2 && elegantText) {
                    setTimeout(() => {
                        elegantText.classList.add('animate');
                    }, 400);
                } else if (elegantText) {
                    elegantText.classList.remove('animate');
                }

                // Débloquer après l'animation
                setTimeout(() => {
                    isAnimating = false;
                }, animationDuration);
            }

            // Vérifier si la section expertise est visible
            function isExpertiseInView() {
                const rect = expertiseTrigger.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                // La section est "in view" si elle occupe une partie significative du viewport
                // OU si on est juste au-dessus/en-dessous (pour capturer les transitions)
                const visibleFromTop = rect.top <= 100 && rect.bottom >= viewportHeight * 0.3;
                const visibleFromBottom = rect.bottom >= viewportHeight - 100 && rect.top <= viewportHeight * 0.7;
                return visibleFromTop || visibleFromBottom;
            }

            // Vérifier si on est au début de la section (pour sortir vers le haut)
            function isAtSectionTop() {
                const rect = expertiseTrigger.getBoundingClientRect();
                return rect.top >= -50 && rect.top <= 100;
            }

            // Vérifier si on est à la fin de la section (pour sortir vers le bas)
            function isAtSectionBottom() {
                const rect = expertiseTrigger.getBoundingClientRect();
                return rect.bottom <= window.innerHeight + 50 && rect.bottom >= window.innerHeight - 100;
            }

            // Vérifier si on entre dans la section par le bas (en remontant)
            function isEnteringFromBottom() {
                const rect = expertiseTrigger.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                // Le bas de la section est visible mais le haut est au-dessus du viewport
                return rect.bottom >= viewportHeight * 0.5 && rect.bottom <= viewportHeight + 50 && rect.top < 0;
            }

            // Vérifier si on est dans la section perspective (pour anticiper le scroll up)
            function isInPerspectiveSection() {
                if (!perspectiveSection) return false;
                const rect = perspectiveSection.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                // On est dans perspective si le haut de la section est visible
                return rect.top <= viewportHeight * 0.5 && rect.bottom >= 0;
            }

            // Vérifier si on est au tout début de perspective (zone de transition)
            function isAtPerspectiveTop() {
                if (!perspectiveSection) return false;
                const rect = perspectiveSection.getBoundingClientRect();
                // Zone de transition: le haut de perspective est proche du haut du viewport
                return rect.top >= -100 && rect.top <= 200;
            }

            // Détecter si c'est un scroll molette (deltaY élevé par événement)
            function isWheelScroll(deltaY) {
                // La molette génère typiquement des deltas de 100+ par cran
                // Le trackpad génère des deltas plus petits et fréquents
                return Math.abs(deltaY) >= 50;
            }

            // Gestionnaire du scroll
            function handleWheel(e) {
                const now = Date.now();
                const deltaY = e.deltaY;

                // Reset l'accumulation si trop de temps s'est écoulé
                if (now - lastDeltaTime > DELTA_RESET_TIME) {
                    accumulatedDelta = 0;
                }
                lastDeltaTime = now;

                // Accumuler le delta
                accumulatedDelta += deltaY;

                // Déterminer le seuil selon le type de scroll
                const isWheel = isWheelScroll(deltaY);
                const threshold = isWheel ? WHEEL_THRESHOLD : TRACKPAD_THRESHOLD;

                // Vérifier si on est dans la section expertise
                const inView = isExpertiseInView();

                // CAS SPÉCIAL: On est dans Perspective et on scroll up → préparer phase 1 (début)
                if (!inView && isAtPerspectiveTop() && deltaY < 0) {
                    // Préparer expertise à la première phase pour que l'animation recommence
                    if (currentPhase !== 0) {
                        currentPhase = 0;
                        phases.forEach((p, i) => p.classList.toggle('active', i === 0));
                        expertiseAnimation.setAttribute('data-current-phase', '1');
                        stopLoader();
                        disablePinning();
                        if (elegantText) elegantText.classList.remove('animate');
                    }
                    return; // Laisser le scroll naturel
                }

                // CAS SPÉCIAL: On entre par le bas (remontée) → ne plus capturer, laisser l'entrée se faire
                const enteringFromBottom = isEnteringFromBottom();

                if (!inView && !enteringFromBottom) {
                    wasInExpertiseSection = isInExpertiseSection;
                    isInExpertiseSection = false;
                    return;
                }

                isInExpertiseSection = true;

                // Protection contre scroll rapide
                if (scrollLocked) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Protection contre le spam (changements de direction rapides)
                if (spamLocked) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Détection de spam: surveiller les changements de direction
                const currentDirection = deltaY > 0 ? 1 : (deltaY < 0 ? -1 : 0);
                if (currentDirection !== 0 && lastScrollDirection !== 0 && currentDirection !== lastScrollDirection) {
                    // Changement de direction détecté
                    if (now - lastDirectionChangeTime < SPAM_TIME_WINDOW) {
                        directionChangeCount++;
                        if (directionChangeCount >= SPAM_DIRECTION_THRESHOLD) {
                            // Spam détecté! Verrouiller temporairement
                            spamLocked = true;
                            e.preventDefault();
                            e.stopPropagation();

                            // Réinitialiser après le délai
                            if (spamLockTimer) clearTimeout(spamLockTimer);
                            spamLockTimer = setTimeout(() => {
                                spamLocked = false;
                                directionChangeCount = 0;
                                accumulatedDelta = 0;
                                spamLockTimer = null;
                            }, SPAM_LOCK_DURATION);
                            return;
                        }
                    } else {
                        // Hors fenêtre de temps, reset le compteur
                        directionChangeCount = 1;
                    }
                    lastDirectionChangeTime = now;
                }
                if (currentDirection !== 0) {
                    lastScrollDirection = currentDirection;
                }

                // Si une animation est en cours, bloquer strictement le scroll
                if (isAnimating) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Détection de scroll rapide (molette)
                if (isWheel && now - lastRapidScrollTime < 80) {
                    rapidScrollCount++;
                    if (rapidScrollCount > 3) {
                        // Verrouiller temporairement pour éviter les sauts multiples
                        scrollLocked = true;
                        e.preventDefault();
                        setTimeout(() => {
                            scrollLocked = false;
                            rapidScrollCount = 0;
                            accumulatedDelta = 0;
                        }, 600);
                        return;
                    }
                } else if (!isWheel) {
                    rapidScrollCount = 0;
                }
                lastRapidScrollTime = now;

                // Throttling plus strict pour la molette
                const currentThrottleDelay = isWheel ? expertiseThrottleDelay + 100 : expertiseThrottleDelay;
                if (now - lastWheelTime < currentThrottleDelay) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                const scrollingDown = deltaY > 0;
                const scrollingUp = deltaY < 0;

                // Ignorer les petits mouvements de scroll (seuil adaptatif)
                if (Math.abs(accumulatedDelta) < threshold) {
                    e.preventDefault();
                    return;
                }

                // Bloquer le scroll si on est piégé au milieu des phases
                if (isPinned) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Scroll vers le bas
                if (scrollingDown) {
                    if (currentPhase < totalPhases - 1) {
                        e.preventDefault();
                        e.stopPropagation();
                        lastWheelTime = now;
                        accumulatedDelta = 0; // Reset après action
                        goToPhase(currentPhase + 1);
                    }
                    // Si on est à la dernière phase, laisser le scroll naturel continuer
                }

                // Scroll vers le haut
                if (scrollingUp) {
                    if (currentPhase > 1) {
                        // Ne pas bloquer le scroll pour 2 → 1, juste animer
                        lastWheelTime = now;
                        accumulatedDelta = 0;
                        goToPhase(currentPhase - 1);
                        return;
                    }
                    if (currentPhase === 1) {
                        e.preventDefault();
                        e.stopPropagation();
                        lastWheelTime = now;
                        accumulatedDelta = 0; // Reset après action
                        goToPhase(currentPhase - 1);
                    }
                    // Si on est à la première phase, laisser le scroll naturel continuer
                }
            }

            // Écouter le scroll
            window.addEventListener('wheel', handleWheel, { passive: false });

            // Si le verrou hero est actif, empêcher tout scroll natif (ex: inertie)
            window.addEventListener('scroll', () => {
                if (heroLockActive && heroScrollLockY !== null) {
                    window.scrollTo({ top: heroScrollLockY, behavior: 'auto' });
                }
            }, { passive: true });

            // Système de détection d'entrée dans la section
            let lastScrollY = window.scrollY;
            let hasEnteredFromBottom = false;
            let hasEnteredFromTop = false;

            // Détection d'entrée basée sur la position de scroll
            function checkSectionEntry() {
                const rect = expertiseTrigger.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const currentScrollY = window.scrollY;
                const scrollingDown = currentScrollY > lastScrollY;
                const scrollingUp = currentScrollY < lastScrollY;

                // Détecter si on vient d'entrer dans la section
                const sectionTop = expertiseSection.offsetTop;
                const sectionBottom = sectionTop + expertiseSection.offsetHeight;
                const viewportTop = currentScrollY;
                const viewportBottom = currentScrollY + viewportHeight;

                // Zone d'entrée par le haut (on arrive depuis le hero)
                const enteringFromTop = rect.top <= viewportHeight * 0.3 && rect.top >= -100 && scrollingDown;

                // Zone d'entrée par le bas (on remonte depuis perspective) - ÉLARGIE
                const enteringFromBottom = rect.bottom >= viewportHeight * 0.5 && rect.bottom <= viewportHeight + 200 && scrollingUp;

                // Vérifier si on est dans la zone de transition perspective → expertise
                const perspectiveRect = perspectiveSection?.getBoundingClientRect();
                const comingFromPerspective = perspectiveRect && perspectiveRect.top >= -50 && perspectiveRect.top <= viewportHeight * 0.3 && scrollingUp;

                // Entrée par le haut → phase 0
                if (enteringFromTop && !hasEnteredFromTop && !isInExpertiseSection) {
                    hasEnteredFromTop = true;
                    hasEnteredFromBottom = false;
                    if (currentPhase !== 0 && !isAnimating) {
                        // Forcer la phase 0 sans animation
                        currentPhase = 0;
                        phases.forEach((p, i) => p.classList.toggle('active', i === 0));
                        expertiseAnimation.setAttribute('data-current-phase', '1');
                        stopLoader();
                        if (elegantText) elegantText.classList.remove('animate');
                    }
                }

                // Entrée par le bas → phase 1 (début) pour que l'animation recommence
                if ((enteringFromBottom || comingFromPerspective) && !hasEnteredFromBottom && !isInExpertiseSection) {
                    hasEnteredFromBottom = true;
                    hasEnteredFromTop = false;
                    if (currentPhase !== 0 && !isAnimating) {
                        // Forcer la première phase pour recommencer l'animation
                        currentPhase = 0;
                        phases.forEach((p, i) => p.classList.toggle('active', i === 0));
                        expertiseAnimation.setAttribute('data-current-phase', '1');
                        stopLoader();
                        disablePinning();
                        if (elegantText) elegantText.classList.remove('animate');
                    }
                }

                // Anticipation: même si on n'est pas encore dans expertise, préparer la phase 1 si on scroll up depuis perspective
                if (comingFromPerspective && currentPhase !== 0 && !isAnimating) {
                    currentPhase = 0;
                    phases.forEach((p, i) => p.classList.toggle('active', i === 0));
                    expertiseAnimation.setAttribute('data-current-phase', '1');
                    stopLoader();
                    disablePinning();
                    if (elegantText) elegantText.classList.remove('animate');
                }

                // Reset des flags quand on sort de la section
                if (rect.bottom < 0 || rect.top > viewportHeight) {
                    hasEnteredFromTop = false;
                    hasEnteredFromBottom = false;
                    // Désactiver le pinning si on sort complètement
                    disablePinning();
                }

                lastScrollY = currentScrollY;
            }

            window.addEventListener('scroll', checkSectionEntry, { passive: true });

            // Écouteur pour enforcer le pinning (scroll natif, barre de scroll)
            window.addEventListener('scroll', () => {
                if (isPinned) {
                    enforcePin();
                }
            }, { passive: true });

            // Bloquer le scroll tactile quand on est piégé
            expertiseSection.addEventListener('touchmove', (e) => {
                if (isPinned) {
                    e.preventDefault();
                }
            }, { passive: false });
        })();

        // ==========================================
        // Snap anchors when hovering boundaries (hero / expertise / perspective)
        // ==========================================
        (function() {
            const heroSection = document.getElementById('hero');
            const expertiseSection = document.getElementById('expertise');
            const perspectiveSection = document.getElementById('perspective');
            if (!heroSection || !expertiseSection || !perspectiveSection) return;

            let snapping = false;
            const snapDuration = 800;

            const getHeaderHeight = () => header?.offsetHeight || 0;

            function scrollToAnchor(section) {
                snapping = true;
                const target = section.offsetTop - getHeaderHeight();
                window.scrollTo({ top: target, behavior: 'smooth' });
                setTimeout(() => { snapping = false; }, snapDuration);
            }

            window.addEventListener('wheel', (e) => {
                if (snapping) {
                    e.preventDefault();
                    return;
                }

                const deltaY = e.deltaY;
                const viewportHeight = window.innerHeight;
                const expertiseRect = expertiseSection.getBoundingClientRect();
                const perspectiveRect = perspectiveSection.getBoundingClientRect();
                const heroRect = heroSection.getBoundingClientRect();

                // Remontée uniquement : si on voit le bas d'expertise et le haut de perspective, recale sur expertise
                const expertiseBottomVisible = expertiseRect.bottom > 0 && expertiseRect.bottom < viewportHeight * 0.55;
                const perspectiveTopVisible = perspectiveRect.top < viewportHeight * 0.45;
                if (deltaY < 0 && expertiseBottomVisible && perspectiveTopVisible) {
                    e.preventDefault();
                    scrollToAnchor(expertiseSection);
                    return;
                }

                // Remontée : si on remonte vers le hero et qu'il est partiellement visible, recale sur hero (innovation)
                const heroTopNear = heroRect.top < viewportHeight * 0.3;
                const heroBottomVisible = heroRect.bottom > viewportHeight * 0.2;
                if (deltaY < 0 && heroTopNear && heroBottomVisible) {
                    e.preventDefault();
                    scrollToAnchor(heroSection);
                    return;
                }
            }, { passive: false });
        })();

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
